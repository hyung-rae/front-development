---
title: data type
parent: javascript
nav_order: 1
layout: default
---

<p>
<img alt="Static Badge" src="https://img.shields.io/badge/javascript-%23ffeb3b?logo=javascript&logoColor=white">
</p>

## javascript data type

- primitive type
    - `Number`
    - `String`
    - `Boolean`
    - `null`
    - `undefined`
    - `Symbol`  : es6 에 추가됨

- reference type
    - `Array`
    - `Function`
    - `RegExp`
    - `Set` / `WeakSet` : es6 에 추가됨
    - `Map` / `WeakMap` : es6 에 추가됨
    

이 두가지 type으로 구분되는 기준은 **메모리의 할당 방식 (동작 방식)** 구분 된다.

## javascript 메모리 영역

- stack memory
    - 변수 , 기본형 데이터
    - 정적 할당

- heap memory
    - 참조형 데이터
    - 동적 할당
    

## primitive type 메모리 할당 방식

```jsx
var str;
str = 'hello';

str = 'hello world'
```

1. 메모리 할당 
    
    
    | 주소   | …   | 1002           | 1003 | 1004 | …   |
    | ------ | --- | -------------- | ---- | ---- | --- |
    | 데이터 |     | 이름 : **str** |
    | 값 :   |     |                |      |
2. 값 메모리 할당 , 이후 해당 주소값을 저장
    
    
    | 주소   | …   | 5002        | 5003 | 5004 | …   |
    | ------ | --- | ----------- | ---- | ---- | --- |
    | 데이터 |     | **‘hello’** |      |      |     |
    
    | 주소           | …   | 1002       | 1003 | 1004 | …   |
    | -------------- | --- | ---------- | ---- | ---- | --- |
    | 데이터         |     | 이름 : str |
    | 값 : **#5002** |     |            |      |
3. 재 할당시 값 재 할당 후 해당 **주소값을 직접 변경**
    
    
    | 주소   | …   | 5002        | 5003              | 5004 | …   |
    | ------ | --- | ----------- | ----------------- | ---- | --- |
    | 데이터 |     | **‘hello’** | **‘hello world’** |      |     |
    
    | 주소           | …   | 1002       | 1003 | 1004 | …   |
    | -------------- | --- | ---------- | ---- | ---- | --- |
    | 데이터         |     | 이름 : str |
    | 값 : **#5003** |     |            |      |
    

## reference type 메모리 할당 방식

```jsx
var obj = {
	number : 3,
	arr : [3,4]
};
```

```jsx
obj.arr = "string"
```

**초기값 , 재할당 값**

1. 메모리 할당
    
    
    | 주소           | …   | 1002           | 1003 | 1004 | …   |
    | -------------- | --- | -------------- | ---- | ---- | --- |
    | 데이터         |     | 이름 : **obj** |
    | 값 : **#2002** |     |                |      |
    
    → 값이 재 할당되도 주소값이 안 바뀐다. **(재할당 값 추적)**
    
    → primitive type과의 차이 , `var obj2 = obj` obj 값이 바뀌면 obj2도 바뀌는 이유
    
2. 값 메모리 할당 (메모리 확보) 
    
    
    | 주소   | …   | 2002          | **2003** | 2004          | 2005  | 2006         |
    | ------ | --- | ------------- | -------- | ------------- | ----- | ------------ |
    | 데이터 |     | **#5003 ~ ?** | **3**    | **#8001 ~ ?** | **4** | **‘string’** |
    
    | 주소                      | …              | 5003              | 5004 | 5005 | …   |
    | ------------------------- | -------------- | ----------------- | ---- | ---- | --- |
    | 데이터                    |                | 이름 : **number** |
    | 값 : **#2003**            | 이름 : **arr** |
    | 값 : **~~#2004~~ →#2006** |                |                   |
    
    | 주소          | …                    | 8001                 | 8002 | 8003 | …   |
    | ------------- | -------------------- | -------------------- | ---- | ---- | --- |
    | 데이터        |                      | 이름 : **0 (index)** |
    | 값 :**#2003** | 이름 : **1 (index)** |
    | 값 :**#2005** |                      |                      |
    
    → **값 할당시 동일한 값 비교 후 재사용**
    
3. **garbage collector**
    
    `obj.arr = “string”` 실행시
    
    8001 ~ 8002 메모리는 참조 카운터가 0이 됨 (안쓰이는 값)
    
    → **참조 카운터가 0이 되면 garbage collector로 해당 메모리 삭제**


### 💡 **메모리 값을 직접 저장 하지 않고 , 값의 주소를 참조 하는 이유 ?**   
- 데이터를 할당시에는 느리지만 (값을 비교해서 동일한 값 재사용 하기 때문)    
- 이후에 데이터 값을 비교할때는 비용이 들지 않는다. (주소값이 같으면 같은 값이기 때문)
- 메모리 낭비가 최소화 된다.
